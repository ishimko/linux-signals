# linux-signals
Создать дерево процессов согласно варианта индивидуального задания. 
Процессы непрерывно обмениваются сигналами. Каждый процесс при получении или посылке сигнала выводит на консоль информацию в следующем виде:

<code>N pid ppid послал/получил  USR1/USR2 текущее время (мксек)</code>

где N-номер сына.

Процесс 1, после получения  101 –го по счету сигнала SIGUSR, посылает сыновьям сигнал SIGTERM и ожидает завершения всех сыновей, после чего завершается сам. Процесс 0 ожидает завершения работы процесса 1 после чего завершается сам. Сыновья, получив сигнал SIGTERM, завершают работу с выводом на консоль сообщения вида:

<code>pid    ppid   завершил работу после X-го сигнала SIGUSR1 и Y-го сигнала SIGUSR2</code>

где X,Y – количество посланных за все время работы данным сыном сигналов SIGUSR1 и SIGUSR2

<strong><code>config.h</code> и <code>config.c</code> для варианта 5/5</strong>

<strong><em>ВАЖНАЯ ВЕЩЬ ДЛЯ ИССЛЕДОВАТЕЛЕЙ</em></strong>

В данной лабораторной есть одна неприятная особенность, приводящая к нестабильной работе без слипов, которые по условию запрещены. Нестабильная работа заключается в том, что процессы, которые сами не отправляют сигналов, получают их меньше, чем нужно. Далее привожу объяснение этого на первый взгляд волшебного бага.

По условию отправка нескольким процессам сигнала должна осуществляться за один вызов kill, то есть фактически мы просим все процессы одновременно вызвать обработчики. Также заметим, что не все процессы из группы участвуют в продолжении цепи передачи сигналов, имеются также бездействующие процессы, которые просто выводят информацию о полученном сигнале. Еще один важный факт: полная потеря сигнала процессом может произойти в том случае, когда второй сигнал приходит в момент переустановки обработчика (фактически сразу после прихода первого сигнала). Все сигналы, пришедшие в этот момент, будут утеряны.

На первый взгляд кажется, что одновременный приход нескольких сигналов процессу невозможен, так как обмен сигналами происходит последовательно по цепи. Но он все же возможен и происходит следующим образом: когда сигнал отправляется группе процессов, как правило, только один процесс из группы участвует в продолжении цепи передачи. Момент, когда он отправит сигнал, может наступить раньше, чем все остальные получатели из группы успеют этот сигнал обработать. Поэтому может наступить ситуация, когда следующая группа уже начала обрабатывать сигнал, а предыдущая еще не успела. Если такое будет возникать часто, то цепь передачи сигнало будет вращаться по тем процессам, которые эти сигналы передают, а остальные просто не будут успевать их обрабатывать, так как будут часто возникать ситуации, когда процессу будет приходить несколько сигналов почти одновременно. Этому также будет способствовать многозадачность, которая вполне может выделить больше времени для работы процессам, которые "активнее" остальных (отправляют сигналы).

В качестве костылей для решения проблемы отлично подходит слип или любой другой способ затянуть выполнение кода в обработчике сигнала, чтобы время, которое проходит между получением сигнала и отправкой следующего, было побольше. Также тактовая частота процессора может сказывваться на стабильности. А вот чтобы добиться работы, адекватной в 100% случаев, придется вводить межпроцессные глобальные флаги (с помощью файлов или разделяемой памяти), сигнализирующие процессу, который должен продолжить передачу сигналов, что остальные получатели его группы обработали сигнал. Насколько мне известно, такое по условию тоже запрещено.

<strong>Таким образом написать эту лабораторную корректно, используя те инструменты, которые разрешены, <s>невозможно</s> возможно через костыли. Хорошего дня!</strong>
